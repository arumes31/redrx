<!-- templates/404.html -->
<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Not Found - Redirx</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { 
            background: #000;
            min-height: 100vh; 
            color: #fff;
            position: relative;
            overflow-x: hidden;
            cursor: none;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(ellipse farthest-corner at center, #666 0%, #333 40%, #000 100%);
        }
        .container { max-width: 600px; margin-top: 100px; }
        .card { 
            background: rgba(0, 0, 0, 0.3); 
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
            z-index: 1;
        }
        .alert { 
            background: rgba(108, 117, 125, 0.2); 
            border: 1px solid rgba(108, 117, 125, 0.3); 
            color: #fff; 
            border-left: 4px solid #6c757d;
        }
        .btn { border: 1px solid rgba(255,255,255,0.2); color: #fff; }
        .btn:hover { color: #fff; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="container">
        <div class="card mx-auto">
            <div class="card-body text-center p-5">
                <h1 class="mb-4"><i class="fas fa-search text-secondary"></i> Link Not Found</h1>
                <div class="alert alert-secondary">
                    <h5>Short URL not found.</h5>
                    <p class="mb-0">The requested short link doesn't exist. Check the URL or create a new one.</p>
                </div>
                <a href="/" class="btn btn-primary mt-3">
                    <i class="fas fa-home"></i> Back to Redirx
                </a>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Full Particle Canvas Script
        var canvas = {
            $el: undefined,
            ctx: undefined,
            draw: function () {
                canvas.clear();
                canvas.callback();
                canvas.raf(canvas.draw);
            },
            clear: function () {
                canvas.ctx.clearRect(0, 0, canvas.$el.width, canvas.$el.height);
            },
            rotate: function (opt, callback) {
                var rad = opt.deg * Math.PI / 180;
                canvas.ctx.translate(opt.left, opt.top);
                canvas.ctx.rotate(rad);
                callback();
                canvas.ctx.rotate(rad * -1);
                canvas.ctx.translate(opt.left * -1, opt.top * -1);
            },
            rect: function (opt) {
                opt = canvas.formatSize(opt);
                canvas.drawElement(function () {
                    canvas.ctx.rect(opt.left, opt.top, opt.width, opt.height);
                });
                canvas.style(opt);
            },
            line: function (opt) {
                canvas.drawElement(function () {
                    canvas.ctx.moveTo(opt.start.x, opt.start.y);
                    canvas.ctx.lineTo(opt.end.x, opt.end.y);
                    canvas.ctx.moveTo(opt.start.x * -1, opt.start.y * -1);
                });
                canvas.style(opt);
            },
            curve: function (opt) {
                canvas.drawElement(function () {
                    canvas.ctx.moveTo(opt.start.x, opt.start.y);
                    canvas.ctx.quadraticCurveTo(opt.start.x, opt.start.y, opt.end.x, opt.end.y);
                    canvas.ctx.moveTo(opt.start.x * -1, opt.start.y * -1);
                });
                canvas.style(opt);
            },
            ellipse: function (opt) {
                opt = canvas.formatSize(opt);
                canvas.drawElement(function () {
                    canvas.ctx.ellipse(opt.left, opt.top, opt.width, opt.height, 0, 0, 2 * Math.PI);
                });
                canvas.style(opt);
            },
            drawElement: function (callback) {
                canvas.ctx.beginPath();
                callback();
                canvas.ctx.closePath();
            },
            style: function (opt) {
                if (!opt) return;
                if (opt.fill) {
                    canvas.ctx.fillStyle = opt.fill;
                    canvas.ctx.fill();
                }
                if (opt.stroke) {
                    canvas.ctx.strokeStyle = opt.stroke;
                    canvas.ctx.stroke();
                }
                if (opt.alpha) {
                    canvas.ctx.globalAlpha = opt.alpha;
                }
            },
            formatSize: function (opt) {
                if ((!opt.width || !opt.height) && opt.size) {
                    opt.width = opt.size;
                    opt.height = opt.size;
                }
                return opt;
            },
            raf: function (callback) {
                var call = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) { setTimeout(callback, 1000 / 60); };
                return call(callback);
            },
            init: function ($el, callback) {
                canvas.$el = $el;
                canvas.callback = callback;
                if (canvas.$el.getContext) {
                    canvas.ctx = canvas.$el.getContext("2d");
                    canvas.draw();
                }
            }
        };

        var target = document.querySelector('#canvas');
        target.height = window.innerHeight;
        target.width = window.innerWidth;

        var dots = {
            settings: {
                bounds: {
                    start: { x: -100, y: -100 },
                    end: { x: target.width + 100, y: target.height + 100 }
                },
                max: 50,
                generate: { auto: true, speed: 250, events: ["click"] },
                move: { enabled: true, tick: 0.5, interval: { min: 1000, max: 30000 } },
                shake: { enabled: true, tick: 0.25 },
                alpha: { randomize: true, tick: 0.005, min: 0.1, max: 0.2 },
                color: { randomize: true, tick: 1, luminosity: { min: 200, max: 255 } },
                linkDots: true
            },
            frames: 0,
            callback: undefined,
            dotCount: 0,
            elements: [],
            rand: function (min, max) { return Math.round(Math.random() * (max - min) + min); },
            randomIncrementOrDecrement: function (value, tick) { return value + tick * (this.rand(0, 2) - 1); },
            limit: function (value, min, max) { if (value < min) value = min; else if (value > max) value = max; return value; },
            drawLines: function () {
                if (!this.settings.linkDots) return;
                var gradient;
                for (var a = 0; a < this.elements.length; a++) {
                    for (var b = 0; b < this.elements.length; b++) {
                        if (this.elements[a] === this.elements[b]) continue;
                        gradient = canvas.ctx.createLinearGradient(this.elements[a].position.x, this.elements[a].position.y, this.elements[b].position.x, this.elements[b].position.y);
                        gradient.addColorStop("0", this.elements[a].color);
                        gradient.addColorStop("1.0", this.elements[b].color);
                        canvas.curve({
                            start: { x: this.elements[a].position.x, y: this.elements[a].position.y },
                            end: { x: this.elements[b].position.x, y: this.elements[b].position.y },
                            stroke: gradient
                        });
                    }
                }
            },
            frame: function () {
                this.frames++;
                var i;
                for (i = 0; i < this.elements.length; i++) {
                    if (this.settings.move.enabled) {
                        this.elements[i].position.x += this.settings.move.tick * this.elements[i].position.direction.x;
                        this.elements[i].position.y += this.settings.move.tick * this.elements[i].position.direction.y;
                    }
                    if (this.settings.shake.enabled) {
                        this.elements[i].position.x = this.randomIncrementOrDecrement(this.elements[i].position.x, this.settings.shake.tick);
                        this.elements[i].position.y = this.randomIncrementOrDecrement(this.elements[i].position.y, this.settings.shake.tick);
                    }
                    this.elements[i].position.x = this.limit(this.elements[i].position.x, this.settings.bounds.start.x, this.settings.bounds.end.x);
                    this.elements[i].position.y = this.limit(this.elements[i].position.y, this.settings.bounds.start.y, this.settings.bounds.end.y);
                    if (this.settings.color.randomize) {
                        this.elements[i].red = this.randomIncrementOrDecrement(this.elements[i].red, this.settings.color.tick);
                        this.elements[i].green = this.randomIncrementOrDecrement(this.elements[i].green, this.settings.color.tick);
                        this.elements[i].blue = this.randomIncrementOrDecrement(this.elements[i].blue, this.settings.color.tick);
                        this.elements[i].red = this.limit(this.elements[i].red, this.settings.color.luminosity.min, this.settings.color.luminosity.max);
                        this.elements[i].green = this.limit(this.elements[i].green, this.settings.color.luminosity.min, this.settings.color.luminosity.max);
                        this.elements[i].blue = this.limit(this.elements[i].blue, this.settings.color.luminosity.min, this.settings.color.luminosity.max);
                    }
                    if (this.settings.alpha.randomize) {
                        this.elements[i].alpha = this.randomIncrementOrDecrement(this.elements[i].alpha, this.settings.alpha.tick);
                        this.elements[i].alpha = this.limit(this.elements[i].alpha, this.settings.alpha.min, this.settings.alpha.max);
                    }
                    this.elements[i].color = 'rgba(' + this.elements[i].red + ',' + this.elements[i].green + ',' + this.elements[i].blue + ', ' + this.elements[i].alpha + ')';
                    canvas.ellipse({
                        left: this.elements[i].position.x,
                        top: this.elements[i].position.y,
                        size: this.elements[i].size,
                        fill: this.elements[i].color
                    });
                }
                this.drawLines();
            },
            direction: {
                setX: function (i) {
                    dots.elements[i].position.direction.x = dots.rand(-1, 1);
                    setTimeout(function () { dots.direction.setX(i); }, dots.rand(dots.settings.move.interval.min, dots.settings.move.interval.max));
                },
                setY: function (i) {
                    dots.elements[i].position.direction.y = dots.rand(-1, 1);
                    setTimeout(function () { dots.direction.setY(i); }, dots.rand(dots.settings.move.interval.min, dots.settings.move.interval.max));
                },
                set: function () {
                    dots.direction.setX(dots.elements.length - 1);
                    dots.direction.setY(dots.elements.length - 1);
                }
            },
            addDot: function (opt, callback) {
                if (this.dotCount < this.settings.max) {
                    this.elements.push({
                        position: {
                            x: opt.x,
                            y: opt.y,
                            direction: { x: this.rand(-1, 1), y: this.rand(-1, 1) }
                        },
                        size: 2,
                        red: this.rand(this.settings.color.luminosity.min, this.settings.color.luminosity.max),
                        green: this.rand(this.settings.color.luminosity.min, this.settings.color.luminosity.max),
                        blue: this.rand(this.settings.color.luminosity.min, this.settings.color.luminosity.max),
                        alpha: this.settings.alpha.min
                    });
                    this.dotCount++;
                    this.direction.set();
                    if (callback) callback();
                }
            },
            eventsGenerate: function () {
                var i;
                if (this.dotCount >= this.settings.max) return;
                for (i = 0; i < this.settings.generate.events.length; i++) {
                    window.addEventListener(this.settings.generate.events[i], function (e) {
                        if (dots.dotCount < dots.settings.max) {
                            dots.addDot({ x: e.pageX, y: e.pageY });
                        }
                    });
                }
            },
            autoGenerate: function () {
                if (this.dotCount >= this.settings.max) return;
                this.addDot({
                    x: this.rand(this.settings.bounds.start.x, this.settings.bounds.end.x),
                    y: this.rand(this.settings.bounds.start.y, this.settings.bounds.end.y)
                }, function () {
                    if (dots.dotCount < dots.settings.max) {
                        setTimeout(dots.autoGenerate, dots.settings.generate.speed);
                    }
                });
            },
            init: function () {
                if (this.settings.generate.auto) this.autoGenerate();
                this.eventsGenerate();
            }
        };

        window.addEventListener('load', function () {
            canvas.init(target, function () { dots.frame(); });
            dots.init();
        });

        window.addEventListener('resize', function () {
            target.height = window.innerHeight;
            target.width = window.innerWidth;
            dots.settings.bounds.end.x = target.width + 100;
            dots.settings.bounds.end.y = target.height + 100;
        });

        // Red Mouse Tail Animation
        const trailCtx = target.getContext('2d');
        let mouseTrail = [];
        const trailLength = 20;
        const trailMaxAge = 30;

        function updateCursor(e) {
            const cursor = document.createElement('div');
            cursor.style.position = 'fixed';
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
            cursor.style.width = '10px';
            cursor.style.height = '10px';
            cursor.style.background = 'red';
            cursor.style.borderRadius = '50%';
            cursor.style.pointerEvents = 'none';
            cursor.style.zIndex = '9999';
            cursor.style.opacity = '0.7';
            document.body.appendChild(cursor);
            setTimeout(() => cursor.remove(), 100);
        }

        document.addEventListener('mousemove', (e) => {
            updateCursor(e);
            mouseTrail.push({
                x: e.clientX,
                y: e.clientY,
                age: 0
            });
            if (mouseTrail.length > trailLength) {
                mouseTrail.shift();
            }
        });

        function drawTrail() {
            trailCtx.save();
            trailCtx.globalCompositeOperation = 'lighter';
            mouseTrail.forEach((point, index) => {
                const alpha = (1 - (point.age / trailMaxAge)) * 0.8;
                const size = (trailMaxAge - point.age) / 3;
                trailCtx.beginPath();
                trailCtx.arc(point.x, point.y, size, 0, Math.PI * 2);
                trailCtx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                trailCtx.fill();
                point.age++;
            });
            mouseTrail = mouseTrail.filter(point => point.age < trailMaxAge);
            trailCtx.restore();
            requestAnimationFrame(drawTrail);
        }

        drawTrail();
    </script>
</body>
</html>